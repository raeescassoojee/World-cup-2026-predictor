{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "de34c6e7-db59-45f4-ba02-e80d2f75a0df",
   "metadata": {},
   "outputs": [
    {
     "ename": "FileNotFoundError",
     "evalue": "[Errno 2] No such file or directory: 'xgb_model.pkl'",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mFileNotFoundError\u001b[39m                         Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[2]\u001b[39m\u001b[32m, line 9\u001b[39m\n\u001b[32m      6\u001b[39m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34;01mjoblib\u001b[39;00m\n\u001b[32m      8\u001b[39m \u001b[38;5;66;03m# Load saved model and data\u001b[39;00m\n\u001b[32m----> \u001b[39m\u001b[32m9\u001b[39m model = \u001b[43mjoblib\u001b[49m\u001b[43m.\u001b[49m\u001b[43mload\u001b[49m\u001b[43m(\u001b[49m\u001b[33;43m'\u001b[39;49m\u001b[33;43mxgb_model.pkl\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[32m     10\u001b[39m le = joblib.load(\u001b[33m'\u001b[39m\u001b[33mlabel_encoder.pkl\u001b[39m\u001b[33m'\u001b[39m)\n\u001b[32m     11\u001b[39m df = pd.read_csv(\u001b[33m'\u001b[39m\u001b[33mdf_processed.csv\u001b[39m\u001b[33m'\u001b[39m)\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~\\anaconda3\\envs\\ds-beginner\\Lib\\site-packages\\joblib\\numpy_pickle.py:735\u001b[39m, in \u001b[36mload\u001b[39m\u001b[34m(filename, mmap_mode, ensure_native_byte_order)\u001b[39m\n\u001b[32m    733\u001b[39m         obj = _unpickle(fobj, ensure_native_byte_order=ensure_native_byte_order)\n\u001b[32m    734\u001b[39m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[32m--> \u001b[39m\u001b[32m735\u001b[39m     \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28;43mopen\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mfilename\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[33;43m\"\u001b[39;49m\u001b[33;43mrb\u001b[39;49m\u001b[33;43m\"\u001b[39;49m\u001b[43m)\u001b[49m \u001b[38;5;28;01mas\u001b[39;00m f:\n\u001b[32m    736\u001b[39m         \u001b[38;5;28;01mwith\u001b[39;00m _validate_fileobject_and_memmap(f, filename, mmap_mode) \u001b[38;5;28;01mas\u001b[39;00m (\n\u001b[32m    737\u001b[39m             fobj,\n\u001b[32m    738\u001b[39m             validated_mmap_mode,\n\u001b[32m    739\u001b[39m         ):\n\u001b[32m    740\u001b[39m             \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(fobj, \u001b[38;5;28mstr\u001b[39m):\n\u001b[32m    741\u001b[39m                 \u001b[38;5;66;03m# if the returned file object is a string, this means we\u001b[39;00m\n\u001b[32m    742\u001b[39m                 \u001b[38;5;66;03m# try to load a pickle file generated with an version of\u001b[39;00m\n\u001b[32m    743\u001b[39m                 \u001b[38;5;66;03m# Joblib so we load it with joblib compatibility function.\u001b[39;00m\n",
      "\u001b[31mFileNotFoundError\u001b[39m: [Errno 2] No such file or directory: 'xgb_model.pkl'"
     ]
    }
   ],
   "source": [
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import plotly.graph_objects as go\n",
    "import plotly.express as px\n",
    "import joblib\n",
    "\n",
    "# Load saved model and data\n",
    "model = joblib.load('xgb_model.pkl')\n",
    "le = joblib.load('label_encoder.pkl')\n",
    "df = pd.read_csv('df_processed.csv')\n",
    "df['date'] = pd.to_datetime(df['date'])\n",
    "\n",
    "# --- Functions (same as notebook) ---\n",
    "tournament_weight = {\n",
    "    'FIFA World Cup': 1.0, 'Copa Am√©rica': 0.85, 'UEFA Euro': 0.85,\n",
    "    'African Cup of Nations': 0.85, 'AFC Asian Cup': 0.85, 'CONCACAF Gold Cup': 0.80,\n",
    "    'FIFA World Cup qualification': 0.75, 'UEFA Euro qualification': 0.70,\n",
    "    'African Cup of Nations qualification': 0.70, 'AFC Asian Cup qualification': 0.70,\n",
    "    'UEFA Nations League': 0.70, 'CONCACAF Nations League': 0.65, 'Friendly': 0.4\n",
    "}\n",
    "df['match_weight'] = df['tournament'].map(tournament_weight).fillna(0.5)\n",
    "\n",
    "def get_team_stats(df, team, date, n_matches=30):\n",
    "    team_matches = df[\n",
    "        ((df['home_team'] == team) | (df['away_team'] == team)) &\n",
    "        (df['date'] < date)\n",
    "    ].tail(n_matches)\n",
    "    if len(team_matches) < 5:\n",
    "        return None\n",
    "    stats = {}\n",
    "    stats['matches_played'] = len(team_matches)\n",
    "    wins = draws = losses = goals_scored = goals_conceded = 0\n",
    "    weighted_wins = weighted_points = 0\n",
    "    for _, match in team_matches.iterrows():\n",
    "        weight = match['match_weight']\n",
    "        if match['home_team'] == team:\n",
    "            gs, gc = match['home_score'], match['away_score']\n",
    "        else:\n",
    "            gs, gc = match['away_score'], match['home_score']\n",
    "        goals_scored += gs\n",
    "        goals_conceded += gc\n",
    "        if gs > gc:\n",
    "            wins += 1; weighted_wins += weight; weighted_points += 3 * weight\n",
    "        elif gs == gc:\n",
    "            draws += 1; weighted_points += 1 * weight\n",
    "        else:\n",
    "            losses += 1\n",
    "    n = len(team_matches)\n",
    "    stats['win_rate'] = wins / n\n",
    "    stats['draw_rate'] = draws / n\n",
    "    stats['loss_rate'] = losses / n\n",
    "    stats['wins'] = wins\n",
    "    stats['draws'] = draws\n",
    "    stats['losses'] = losses\n",
    "    stats['avg_goals_scored'] = goals_scored / n\n",
    "    stats['avg_goals_conceded'] = goals_conceded / n\n",
    "    stats['goal_diff_avg'] = stats['avg_goals_scored'] - stats['avg_goals_conceded']\n",
    "    stats['weighted_win_rate'] = weighted_wins / n\n",
    "    stats['weighted_points_avg'] = weighted_points / n\n",
    "    return stats\n",
    "\n",
    "def get_head_to_head(df, team1, team2, date, n_matches=10):\n",
    "    h2h = df[\n",
    "        (((df['home_team'] == team1) & (df['away_team'] == team2)) |\n",
    "         ((df['home_team'] == team2) & (df['away_team'] == team1))) &\n",
    "        (df['date'] < date)\n",
    "    ].tail(n_matches)\n",
    "    if len(h2h) == 0:\n",
    "        return {'h2h_win_rate': 0.5, 'h2h_goal_diff': 0, 'h2h_matches': 0, 'results': []}\n",
    "    team1_wins = team2_wins = draws = 0\n",
    "    team1_goal_diff = 0\n",
    "    results = []\n",
    "    for _, match in h2h.iterrows():\n",
    "        if match['home_team'] == team1:\n",
    "            diff = match['home_score'] - match['away_score']\n",
    "            results.append({'date': match['date'], 'score': f\"{match['home_score']}-{match['away_score']}\", \n",
    "                          'home': team1, 'away': team2, 'tournament': match['tournament']})\n",
    "        else:\n",
    "            diff = match['away_score'] - match['home_score']\n",
    "            results.append({'date': match['date'], 'score': f\"{match['away_score']}-{match['home_score']}\", \n",
    "                          'home': team2, 'away': team1, 'tournament': match['tournament']})\n",
    "        team1_goal_diff += diff\n",
    "        if diff > 0: team1_wins += 1\n",
    "        elif diff == 0: draws += 1\n",
    "        else: team2_wins += 1\n",
    "    return {\n",
    "        'h2h_win_rate': team1_wins / len(h2h), 'h2h_goal_diff': team1_goal_diff / len(h2h),\n",
    "        'h2h_matches': len(h2h), 'team1_wins': team1_wins, 'team2_wins': team2_wins,\n",
    "        'draws': draws, 'results': results\n",
    "    }\n",
    "\n",
    "def predict_match(home_team, away_team, neutral=False):\n",
    "    date = df['date'].max()\n",
    "    home_stats = get_team_stats(df, home_team, date)\n",
    "    away_stats = get_team_stats(df, away_team, date)\n",
    "    if home_stats is None or away_stats is None:\n",
    "        return None, None, None, None\n",
    "    h2h = get_head_to_head(df, home_team, away_team, date)\n",
    "    match_features = pd.DataFrame([{\n",
    "        'home_win_rate': home_stats['win_rate'], 'home_goals_scored': home_stats['avg_goals_scored'],\n",
    "        'home_goals_conceded': home_stats['avg_goals_conceded'], 'home_goal_diff': home_stats['goal_diff_avg'],\n",
    "        'home_weighted_points': home_stats['weighted_points_avg'], 'away_win_rate': away_stats['win_rate'],\n",
    "        'away_goals_scored': away_stats['avg_goals_scored'], 'away_goals_conceded': away_stats['avg_goals_conceded'],\n",
    "        'away_goal_diff': away_stats['goal_diff_avg'], 'away_weighted_points': away_stats['weighted_points_avg'],\n",
    "        'win_rate_diff': home_stats['win_rate'] - away_stats['win_rate'],\n",
    "        'goal_diff_diff': home_stats['goal_diff_avg'] - away_stats['goal_diff_avg'],\n",
    "        'weighted_points_diff': home_stats['weighted_points_avg'] - away_stats['weighted_points_avg'],\n",
    "        'goals_scored_diff': home_stats['avg_goals_scored'] - away_stats['avg_goals_scored'],\n",
    "        'goals_conceded_diff': home_stats['avg_goals_conceded'] - away_stats['avg_goals_conceded'],\n",
    "        'h2h_win_rate': h2h['h2h_win_rate'], 'h2h_goal_diff': h2h['h2h_goal_diff'],\n",
    "        'h2h_matches': h2h['h2h_matches'], 'is_neutral': int(neutral), 'match_weight': 1.0\n",
    "    }])\n",
    "    probs = model.predict_proba(match_features)[0]\n",
    "    prob_dict = {cls: prob for cls, prob in zip(le.classes_, probs)}\n",
    "    return prob_dict, home_stats, away_stats, h2h\n",
    "\n",
    "# --- Streamlit Dashboard ---\n",
    "st.set_page_config(page_title=\"World Cup Predictor\", page_icon=\"‚öΩ\", layout=\"wide\")\n",
    "\n",
    "st.title(\"‚öΩ World Cup Match Predictor\")\n",
    "st.markdown(\"*ML-powered match predictions using 150+ years of international football data*\")\n",
    "\n",
    "# Get all teams sorted\n",
    "all_teams = sorted(list(set(df['home_team'].unique()) | set(df['away_team'].unique())))\n",
    "\n",
    "# Sidebar\n",
    "st.sidebar.header(\"Match Setup\")\n",
    "home_team = st.sidebar.selectbox(\"Home Team\", all_teams, index=all_teams.index('Brazil'))\n",
    "away_team = st.sidebar.selectbox(\"Away Team\", all_teams, index=all_teams.index('Argentina'))\n",
    "neutral = st.sidebar.checkbox(\"Neutral Venue\", value=True)\n",
    "predict_btn = st.sidebar.button(\"üîÆ Predict Match\", use_container_width=True)\n",
    "\n",
    "if predict_btn and home_team != away_team:\n",
    "    probs, home_stats, away_stats, h2h = predict_match(home_team, away_team, neutral)\n",
    "    \n",
    "    if probs is None:\n",
    "        st.error(\"Not enough data for one of these teams\")\n",
    "    else:\n",
    "        # --- Prediction Results ---\n",
    "        st.header(f\"{home_team} vs {away_team}\")\n",
    "        \n",
    "        col1, col2, col3 = st.columns(3)\n",
    "        col1.metric(f\"üè† {home_team} Win\", f\"{probs.get('Home Win', 0)*100:.1f}%\")\n",
    "        col2.metric(\"ü§ù Draw\", f\"{probs.get('Draw', 0)*100:.1f}%\")\n",
    "        col3.metric(f\"‚úàÔ∏è {away_team} Win\", f\"{probs.get('Away Win', 0)*100:.1f}%\")\n",
    "        \n",
    "        # Probability bar chart\n",
    "        fig_probs = go.Figure(go.Bar(\n",
    "            x=[probs.get('Home Win', 0)*100, probs.get('Draw', 0)*100, probs.get('Away Win', 0)*100],\n",
    "            y=[f'{home_team} Win', 'Draw', f'{away_team} Win'],\n",
    "            orientation='h',\n",
    "            marker_color=['#2ecc71', '#f39c12', '#e74c3c'],\n",
    "            text=[f\"{probs.get('Home Win', 0)*100:.1f}%\", f\"{probs.get('Draw', 0)*100:.1f}%\", f\"{probs.get('Away Win', 0)*100:.1f}%\"],\n",
    "            textposition='auto'\n",
    "        ))\n",
    "        fig_probs.update_layout(title=\"Win Probability\", xaxis_title=\"Probability %\", \n",
    "                                 height=250, margin=dict(t=40, b=20))\n",
    "        st.plotly_chart(fig_probs, use_container_width=True)\n",
    "        \n",
    "        # --- Team Comparison ---\n",
    "        st.header(\"üìä Team Comparison (Last 30 Matches)\")\n",
    "        \n",
    "        col1, col2 = st.columns(2)\n",
    "        \n",
    "        with col1:\n",
    "            st.subheader(home_team)\n",
    "            subcol1, subcol2, subcol3 = st.columns(3)\n",
    "            subcol1.metric(\"Win Rate\", f\"{home_stats['win_rate']*100:.0f}%\")\n",
    "            subcol2.metric(\"Goals/Game\", f\"{home_stats['avg_goals_scored']:.1f}\")\n",
    "            subcol3.metric(\"Conceded/Game\", f\"{home_stats['avg_goals_conceded']:.1f}\")\n",
    "            \n",
    "            fig_home = go.Figure(go.Pie(\n",
    "                values=[home_stats['wins'], home_stats['draws'], home_stats['losses']],\n",
    "                labels=['Wins', 'Draws', 'Losses'],\n",
    "                marker_colors=['#2ecc71', '#f39c12', '#e74c3c'],\n",
    "                hole=0.4\n",
    "            ))\n",
    "            fig_home.update_layout(title=f\"{home_team} Results\", height=300, margin=dict(t=40, b=20))\n",
    "            st.plotly_chart(fig_home, use_container_width=True)\n",
    "        \n",
    "        with col2:\n",
    "            st.subheader(away_team)\n",
    "            subcol1, subcol2, subcol3 = st.columns(3)\n",
    "            subcol1.metric(\"Win Rate\", f\"{away_stats['win_rate']*100:.0f}%\")\n",
    "            subcol2.metric(\"Goals/Game\", f\"{away_stats['avg_goals_scored']:.1f}\")\n",
    "            subcol3.metric(\"Conceded/Game\", f\"{away_stats['avg_goals_conceded']:.1f}\")\n",
    "            \n",
    "            fig_away = go.Figure(go.Pie(\n",
    "                values=[away_stats['wins'], away_stats['draws'], away_stats['losses']],\n",
    "                labels=['Wins', 'Draws', 'Losses'],\n",
    "                marker_colors=['#2ecc71', '#f39c12', '#e74c3c'],\n",
    "                hole=0.4\n",
    "            ))\n",
    "            fig_away.update_layout(title=f\"{away_team} Results\", height=300, margin=dict(t=40, b=20))\n",
    "            st.plotly_chart(fig_away, use_container_width=True)\n",
    "        \n",
    "        # --- Radar Comparison ---\n",
    "        categories = ['Win Rate', 'Goals Scored', 'Goal Diff', 'Weighted Points', 'H2H Win Rate']\n",
    "        home_vals = [home_stats['win_rate'], home_stats['avg_goals_scored']/3, \n",
    "                     (home_stats['goal_diff_avg']+2)/4, home_stats['weighted_points_avg']/3, h2h['h2h_win_rate']]\n",
    "        away_vals = [away_stats['win_rate'], away_stats['avg_goals_scored']/3,\n",
    "                     (away_stats['goal_diff_avg']+2)/4, away_stats['weighted_points_avg']/3, 1-h2h['h2h_win_rate']]\n",
    "        \n",
    "        fig_radar = go.Figure()\n",
    "        fig_radar.add_trace(go.Scatterpolar(r=home_vals + [home_vals[0]], theta=categories + [categories[0]],\n",
    "                                             fill='toself', name=home_team, line_color='#2ecc71'))\n",
    "        fig_radar.add_trace(go.Scatterpolar(r=away_vals + [away_vals[0]], theta=categories + [categories[0]],\n",
    "                                             fill='toself', name=away_team, line_color='#e74c3c'))\n",
    "        fig_radar.update_layout(title=\"Team Radar Comparison\", polar=dict(radialaxis=dict(range=[0, 1])),\n",
    "                                 height=400)\n",
    "        st.plotly_chart(fig_radar, use_container_width=True)\n",
    "        \n",
    "        # --- Head to Head ---\n",
    "        if h2h['h2h_matches'] > 0:\n",
    "            st.header(f\"‚öîÔ∏è Head to Head ({h2h['h2h_matches']} matches)\")\n",
    "            col1, col2, col3 = st.columns(3)\n",
    "            col1.metric(f\"{home_team} Wins\", h2h['team1_wins'])\n",
    "            col2.metric(\"Draws\", h2h['draws'])\n",
    "            col3.metric(f\"{away_team} Wins\", h2h['team2_wins'])\n",
    "            \n",
    "            if h2h['results']:\n",
    "                h2h_df = pd.DataFrame(h2h['results'])\n",
    "                h2h_df['date'] = pd.to_datetime(h2h_df['date']).dt.strftime('%Y-%m-%d')\n",
    "                st.dataframe(h2h_df[['date', 'home', 'away', 'score', 'tournament']], \n",
    "                           use_container_width=True, hide_index=True)\n",
    "\n",
    "elif home_team == away_team:\n",
    "    st.warning(\"Please select two different teams\")\n",
    "else:\n",
    "    st.info(\"üëà Select two teams and click Predict Match to get started!\")\n",
    "\n",
    "st.markdown(\"---\")\n",
    "st.caption(\"Built with XGBoost ML | Data: 49,071 international matches (1872-2026)\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bf1b5531-4dc8-4c33-bd8d-385723fcf00a",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.14"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
